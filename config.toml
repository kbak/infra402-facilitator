# x402 Facilitator Configuration Example
#
# This file shows all available configuration options for the x402 facilitator.
# Copy this file to `config.toml` and customize as needed.
#
# Configuration file location can be specified via CONFIG_FILE environment variable:
#   CONFIG_FILE=/path/to/config.toml infra402-facilitator
#
# Default location: ./config.toml (in current directory)

# ================================
# Rate Limiting Configuration
# ================================
[rate_limiting]
# Enable or disable rate limiting globally
enabled = true

# Global rate limit (requests per second per IP address)
# This applies to all endpoints unless overridden
requests_per_second = 50

# Duration in seconds to ban an IP after threshold violations
# Default: 300 seconds (5 minutes)
ban_duration_seconds = 600

# Number of rate limit violations before triggering a temporary ban
# Default: 5 violations
ban_threshold = 5

# IPs exempt from rate limiting (localhost by default)
# Local IP ranges are included by default for development/testing
whitelisted_ips = [
    "127.0.0.0/8",      # IPv4 localhost
    "::1/128",          # IPv6 localhost
    # Add trusted IPs here:
    # "10.0.0.0/8",     # Example: Internal network
]

# Per-endpoint rate limit overrides (optional)
# Specify custom limits for specific endpoints
[rate_limiting.endpoints]
# Example: Limit /verify endpoint to 5 requests/second
verify = 25
# Example: Limit /settle endpoint to 2 requests/second
settle = 25
# Note: endpoint names should match route paths without leading slash

# ================================
# CORS Configuration
# ================================
[cors]
# List of allowed origins for CORS requests
# Empty list = allow all origins (*)
# Specify exact origins for production:
allowed_origins = [
    # "https://example.com",
    # "https://app.example.com",
]

# ================================
# IP Filtering Configuration
# ================================
[ip_filtering]
# List of allowed IP addresses or CIDR blocks
# Empty list = allow all IPs
# If specified, ONLY these IPs/ranges will be allowed
allowed_ips = [
    # "192.168.1.0/24",
    # "10.0.0.1",
]

# List of blocked IP addresses or CIDR blocks
# IPs on this list will be rejected regardless of allow list
blocked_ips = [
    # "192.0.2.0/24",
    # "198.51.100.50",
]

# ================================
# Request Configuration
# ================================
[request]
# Maximum request body size in bytes
# Default: 1048576 (1 MB)
# Prevents abuse via large payloads
max_body_size_bytes = 1048576

# ================================
# Security Configuration
# ================================
[security]
# Require API key authentication for /health endpoint
# Default: false (public access)
health_endpoint_requires_auth = false

# Enable logging of security-related events
# Includes: rate limit violations, auth failures, blocked IPs, etc.
# Default: true
log_security_events = true

# Cleanup interval for abuse detector and rate limiter (in seconds)
# This controls how often old tracking data is purged from memory
# Default: 300 seconds (5 minutes)
cleanup_interval_seconds = 3600

# ================================
# Transaction Configuration
# ================================
[transaction]
# Default RPC request timeout in seconds
# This is used as a fallback when chain-specific configuration is not provided
# Default: 30 seconds
default_rpc_timeout_seconds = 30

# HTTP connection pool settings
# Increase these values for high-concurrency scenarios (100+ RPS)
connection_timeout_seconds = 10      # Connection establishment timeout
pool_max_idle_per_host = 100         # Max idle connections per RPC host
pool_idle_timeout_seconds = 90       # Keep-alive timeout for idle connections

# Gas buffer multiplier applied to estimated gas (e.g., 1.2 = 20% buffer)
# Helps prevent out-of-gas errors when RPC estimation is too tight
# Default: 1.0 (no buffer)
gas_buffer = 1.0

# Chain-specific configurations
# Format: [transaction.chains.<network-name>]
# Network name should match the chain ID mapping in src/chain/evm.rs

# BSC (BNB Smart Chain) - Chain ID 56
[transaction.chains.bsc]
block_time_seconds = 3
receipt_timeout_blocks = 20  # 60 seconds total (20 blocks * 3s)
rpc_request_timeout_seconds = 15  # BSC RPCs can be slow/flaky
gas_buffer = 1.2  # More buffer for inaccurate multicall3 estimations

# BSC Testnet - Chain ID 97
[transaction.chains.bsc-testnet]
block_time_seconds = 3
receipt_timeout_blocks = 20  # 60 seconds total
rpc_request_timeout_seconds = 15
gas_buffer = 1.2  # More buffer for inaccurate multicall3 estimations

# Base - Chain ID 8453
[transaction.chains.base]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total (30 blocks * 2s)
rpc_request_timeout_seconds = 20
flashblocks = true  # Use BlockId::latest() for gas estimation (Base Flashblocks)

# Base Sepolia Testnet - Chain ID 84532
[transaction.chains.base-sepolia]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total (30 blocks * 2s)
rpc_request_timeout_seconds = 20

# Ethereum Mainnet - Chain ID 1
[transaction.chains.ethereum]
block_time_seconds = 12
receipt_timeout_blocks = 10  # 120 seconds total (10 blocks * 12s)
rpc_request_timeout_seconds = 30

# Polygon - Chain ID 137
[transaction.chains.polygon]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total
rpc_request_timeout_seconds = 20

# Avalanche C-Chain - Chain ID 43114
[transaction.chains.avalanche]
block_time_seconds = 2
receipt_timeout_blocks = 30  # 60 seconds total
rpc_request_timeout_seconds = 20

# ================================
# Batch Settlement Configuration
# ================================
# Enable Multicall3 batching to bundle multiple settlements into single transactions
# for improved throughput (up to 100-150x) and reduced gas costs (~75% savings)
#
# Supports per-network configuration overrides to tune batching parameters independently
# for each blockchain network (e.g., different batch sizes for Base vs BSC)
[batch_settlement]
# Enable batching globally (default: false for backward compatibility)
enabled = true

# Global default: Maximum settlements per batch (default: 150)
# Theoretical max ~545 based on gas limit, but 150 is safer
max_batch_size = 100

# Global default: Maximum milliseconds to wait before flushing batch (default: 500)
# Lower = better latency, higher = better batching efficiency
max_wait_ms = 1000

# Global default: Minimum batch size for immediate flush (default: 10)
# If queue reaches this size, flush immediately without waiting
min_batch_size = 100

# Global default: Allow individual transfers to fail without reverting entire batch (default: false)
# false = strict (any failure reverts all), true = permissive (continue on failures)
allow_partial_failure = false

# Per-network configuration overrides (optional)
# Only specified fields override global defaults for each network
# Network names: base, base-sepolia, bsc, bsc-testnet, avalanche, avalanche-fuji,
#                polygon, polygon-amoy, sei, sei-testnet, xdc, solana, solana-devnet
#
# Available per-network fields:
# - enabled: Override global enabled setting (true/false)
# - max_batch_size: Override max settlements per batch
# - max_wait_ms: Override max wait time before flushing batch
# - min_batch_size: Override minimum batch size for immediate flush
# - allow_partial_failure: Override partial failure handling

# Example: BSC with larger batches and longer wait time
# [batch_settlement.networks.bsc]
# max_batch_size = 200
# max_wait_ms = 1000
# allow_partial_failure = true

# Example: Enable batching ONLY for BSC testnet (global disabled, per-network enabled)
# [batch_settlement.networks.bsc-testnet]
# enabled = true
# max_batch_size = 100
# max_wait_ms = 1000
# allow_partial_failure = false

# Example: Disable batching for a specific network (global enabled, per-network disabled)
# [batch_settlement.networks.base]
# enabled = false

# Example: Base with smaller batches and faster flush for lower latency
# [batch_settlement.networks.base]
# max_batch_size = 50
# max_wait_ms = 250
# min_batch_size = 5

# Example: Avalanche with aggressive batching for high throughput
# [batch_settlement.networks.avalanche]
# max_batch_size = 300
# max_wait_ms = 2000
# allow_partial_failure = true
